#!/bin/bash
# -*- mode: shell-script; indent-tabs-mode: nil; sh-basic-offset: 4; -*- 
# ex: ts=4 sw=4 sts=4 et filetype=sh
#
# Copyright (C) 2018-2019 Roger Zhou <zzhou@suse.com>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This software is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#

TMP_HOSTS=""
ORG_VM=""
NEW_VM=""

log (){ [ "${IS_DEBUG}_x" = "YES_x" ] || return; echo -e "\r$1"; }
die () { echo "$1"; exit; }
is_cmd_installed () { which $1 >/dev/null 2>&1||die "ERR: $1 not exist"; }

# INPUT:     $*
# OUTPUT:    $CMD_STDOUT
run_cmd ()
{
    local BINCMD RES

    [ "$IS_DEBUG_VVV" = "YES" ] && set -x
 
    CMD_STDOUT=""
    [ -z "$*" ] && die "ERR: no argument for run_cmd()"
    log "run_cmd: $*"
    BINCMD=$(echo "$*"|cut -d' ' -f1)
    which $BINCMD >/dev/null 2>&1||die "ERR: $BINCMD not exist"
 
    #CMD_STDOUT=$( $* 2>&1 )    # Weird STDERR STDOUT makes qemu-nbd hang
    exec 3>&2
    exec 2>&1
    CMD_STDOUT=$( $* )

    RES=$?
    exec 2>&3
    if [ $RES -ne 0 ]; then
        log "$CMD_STDOUT"
        echo "ERR: fatal. Please try --debug."
        die "ERR: failed $*"
    fi
    [ -z "$CMD_STDOUT" ] || log "$CMD_STDOUT"
 
    [ "$IS_DEBUG_VVV" = "YES" ] && set +x
    return 0
}

# INPUT:     $*
# OUTPUT:    $CMD_STDOUT
try_cmd ()
{
    local BINCMD RES

    [ -z "$*" ] && die "ERR: no argument for try_cmd()"
    log "try_cmd: $*"
    BINCMD=$(echo "$*"|cut -d' ' -f1)
    which $BINCMD >/dev/null 2>&1||die "ERR: $BINCMD not exist";
    CMD_STDOUT="$($* 2>&1)"
    RES=$?
    [ -z "$CMD_STDOUT" ] || log "$CMD_STDOUT"
    return $RES
}

function usage ()
{
    echo "Usage: $(basename $0) --original vmname [options]"
    echo -e "
Motivation of this tool is to duplicate a Virtual Machine in seconds.
To reach that speed, the trick is to deploy all VM images in the
filesystem with the native COW(--reflink) capability, eg. btrfs,
xfs-4.16, ocfs2, etc. 

It is created, just because virt-clone does not yet leverage the native
COW(--reflink) capability of the filesystem to duplicate qcow2. It only
support RAW by now at the end of 2018. virt-clone might take noticeable
time to duplicate qcow2 image files. Well, it is understandable
virt-clone wants to keep the advantage of qcow2 backing file
functionality for existent use cases.

Functionalities of this tool includes:
- reset MAC to be unique
- reset hostname to the new Virtual Machine
- an option not to enforce dhcp, and can add secondary IP
- an option to add hostname to hosts


Tips:
- to let a image shared among Virtual Machines, you should avoid
  the Virttual Machine name to be the substring of that image name.


Options:
-h, --help
-v, --verbose, -vv, -vvv for more debugging information
-o, --original ORIGINAL_GUEST_NAME
-n, --name NEW_GUEST_NAME[,ip=w.x.y.z/m,nodhcp,hosts]
     ip=        (optional, no default,  m default 24)
     nodhcp     means no attempt to enforce DHCP (default no this option)
     hosts      means to adjust /etc/hosts (default no this option)

"
    exit
}

####################################################################
# Bash options parsing
#
POSITIONAL=()
while [[ $# -gt 0 ]]
do
key="$1"

case $key in
    -o|--original)
    ORG_VM="$2"
    shift # past argument
    shift # past value
    ;;
    -n|--name)
    NEW_VM="$2"
    shift # past argument
    shift # past value
    ;;
    -f|--file)
    NEW_IMAGE_FILE_PATH="$2"
    shift # past argument
    shift # past value
    ;;
    -r|--reflink)
    IS_REFLINK=YES
    shift # past argument
    ;;
    -h|--help)
    usage
    shift # past argument
    ;;
    -v|--verbose)
    IS_DEBUG=YES
    shift # past argument
    ;;
    -vv)
    IS_DEBUG=YES
    IS_DEBUG_VV=YES
    shift # past argument
    ;;
    -vvv)
    IS_DEBUG=YES
    IS_DEBUG_VV=YES
    IS_DEBUG_VVV=YES
    shift # past argument
    ;;
    *)    # unknown option
    POSITIONAL+=("$1") # save it in an array for later
    shift # past argument
    ;;
esac
done
set -- "${POSITIONAL[@]}" # restore positional parameters


if [[ -n $1 ]]; then
    usage
fi


####################################################################
# NEW_VM option processing
#

# eg. NEW_VM=vm1,ip=192.168.99.1
log "... $NEW_VM ..."
NEW_VM=$(echo $NEW_VM|tr ',' ' ')
for i in $NEW_VM; do
   case $i in
       ip=*)
           NEW_IP_CIDR=${i:3}
           echo $NEW_IP_CIDR|grep -Hv '/'>/dev/null && NEW_IP_CIDR="$NEW_IP_CIDR/24"
           ;;
       nodhcp)
           NOT_RESET_DHCP="YES"
           ;;
       hosts)
           RESET_ETC_HOSTS="YES"
           ;;
   esac
done
log "... $NEW_IP_CIDR ..."

NEW_VM=$(echo $NEW_VM|cut -d' ' -f1)
[[ -z "${NEW_VM}" ]] && NEW_VM="${ORG_VM}_dup"

if [[ $ORG_VM == *"$NEW_VM"* ]]; then
    echo "ERR: the new VM name is substring of the old VM name is prohibited currently."
    exit
fi

echo ${NEW_VM}|grep "[[:space:]]" > /dev/null 2>&1
if [ $? -eq 0 ]; then
    echo "ERR: this script don't work with the VM name has any 'space' char, '${NEW_VM}'"
    exit
fi
 

####################################################################
# This stage is to dump the original VM configuration via libvirt
#
if [ "$EUID" -ne 0 ]; then
    echo "Please run as a root user, or -h | --help"
    exit
fi

DOMAIN_DUP_RANDOM=$RANDOM
if [[ -n ${ORG_VM} ]]; then
    echo ${ORG_VM}|grep "[[:space:]]" > /dev/null 2>&1
    if [ $? -eq 0 ]; then
        echo "ERR: this script don't work with the VM name has any 'space' char, '${ORG_VM}'"
        exit
    fi

    is_cmd_installed "virsh"

    if ! TEXT=$(virsh domstate ${ORG_VM} 2>&1); then
	echo "ERR: the virtual machine $ORG_VM doesn't exist"
	exit
    fi

    if [ "${TEXT}_x" = "shut off_x" ]; then
        log "${ORG_VM} is off."
    else
        run_cmd "virsh suspend ${ORG_VM}"
        echo -n "INFO: ${ORG_VM} get suspended to duplicate GUEST XML"
        IS_SUSPENDED="YES"
    fi

    DUP_XML="/tmp/${ORG_VM}_dup_${DOMAIN_DUP_RANDOM}.xml"
    log `virsh dumpxml ${ORG_VM} > ${DUP_XML}`
else
    usage
fi

if [ "${IS_SUSPENDED}_x" = "YES_x" ]; then
    run_cmd "virsh resume ${ORG_VM}"
#    echo "${ORG_VM} get resumed"
    echo ", ... resumed"
fi

####################################################################
# This stage is to define the new VM configuration via libvirt
#

log "${DUP_XML} is under processing for ${NEW_VM} "
log "$(grep -e "/name" -e "/uuid" -e "<mac address=" -e "<source file=.*${ORG_VM}.*"  ${DUP_XML})"

# find what image files won't change
IMG_FILES_WONT_CHANGE=$(sed -n -E "s@(.*<source file=')(.*)('/>)@\2@p" ${DUP_XML}|grep -v ${ORG_VM})

# handle multiple image files
ORG_VM_IMG_FILES=$(sed -n -E "s@(.*<source file=')(.+${ORG_VM}.+)('/>)@\2@p" ${DUP_XML})

if [[ -z "${ORG_VM_IMG_FILES}" ]]; then
    log "Stop, no result when search $ORG_VM in all image names"
    exit
fi


if TEXT=$(virsh domstate ${NEW_VM} 2>&1); then
    echo "INFO: ${NEW_VM} already exists. Call virsh to destroy and undefine it"
 
    if ! [ "${TEXT}_x" = "shut off_x" ]; then
        TEXT="$(virsh destroy ${NEW_VM} 2>&1)"
        STATUS=$?
        log "${TEXT}"
        if [ "${STATUS}_x" = "1_x" ]; then
            echo "ERR: failed to destroy ${NEW_VM}"
            exit
        fi
    fi
 
    TEXT="$(virsh undefine ${NEW_VM} 2>&1)"
    STATUS=$?
    log "${TEXT}"
    if [ "${STATUS}_x" = "1_x" ]; then
        echo "ERR: failed to undefine ${NEW_VM}"
        exit
    fi
fi

#
#  1. Change Domain Name
sed -i "s#<name>.*</name>#<name>${NEW_VM}</name>#" ${DUP_XML}

#
#  2. Change Domain UUID 
sed -i "s#<uuid>.*</uuid>#<uuid>`cat /proc/sys/kernel/random/uuid`</uuid>#" ${DUP_XML}

#  3. Change MAC address
#  FIXME: what about multiple MAC?
MACADDR="52:54:00:$(echo ${DOMAIN_DUP_RANDOM} | md5sum | sed 's/^\(..\)\(..\)\(..\).*$/\1:\2:\3/')"
sed -i "s#<mac address=.*/>#<mac address='${MACADDR}'/>#" ${DUP_XML}
echo "INFO: reset ${NEW_VM}:MACADDR to $MACADDR"


#
#  4. Change domain image file
#  handle multiple image files
sed -i -E "s@(<source file=.+)${ORG_VM}(.+)@\1${NEW_VM}\2@" ${DUP_XML}

log "${DUP_XML} is processed as"
log "$(grep -e "/name" -e "/uuid" -e "<mac address=" -e "<source file=.*${NEW_VM}.*"  ${DUP_XML})"

if ! TEXT="$(virsh define ${DUP_XML} 2>&1)"; then
    log "${TEXT}"
    echo "ERR: failed to define ${NEW_VM}"
    exit
fi

log "$TEXT"
echo "INFO: ${NEW_VM} VM is newly defined"

####################################################################
# duplicate the image files with --reflink capability
#
NEW_VM_IMG_FILES=""
for i in $ORG_VM_IMG_FILES;
do
    NEW_F=$(echo ${i} | sed -E "s@(.+)${ORG_VM}(.+)@\1${NEW_VM}\2@")
    NEW_VM_IMG_FILES="$NEW_VM_IMG_FILES $NEW_F"
 
    run_cmd "df --output=fstype `dirname ${i}`"
    TMP=""
    TEXT=$(echo "$CMD_STDOUT"|tail -n1)
    [ "$TEXT" = "btrfs" ] && TMP="YES"
    [ "$TEXT" = "ocfs2" ] && TMP="YES"
    [ "$TEXT" = "xfs" ] && [ $(uname -r | cut -d'.' -f2) -ge 16 ] \
        && TMP="YES"
 
    CMD="cp --reflink=auto -f ${i} ${NEW_F}"
    if ! [ "$TMP" = "YES" ]; then
        echo "INFO: no reflink support fs, copying might take time..."
    fi
    echo "INFO: $CMD"
 
    run_cmd "$CMD"
    run_cmd "fsync $NEW_F"
done

####################################################################
# virt-sysprep
#

# FIXME: seems virt-sysprep is not appropriate for this tool. 
function reset_hostname_via_sysprep ()
{
    echo "reset hostname, net, etc. will need tens of seconds"
    CMD="virt-sysprep -d $NEW_VM --hostname $NEW_VM --enable net-hwaddr,machine-id --run 'echo $NEW_VM > /etc/hostname'"
    echo "$CMD"
    log "`$CMD 2>&1`"
}

function find_unused_lo_device_node ()
{
    NUMS=$(lsblk|cut -d' ' -f1|grep loop|sed 's/loop//')
    DEV=""
    for i in {0..100}
    do
        LOOP_DEV_EXIST="NO"
        for j in $NUMS; do
           [ "${i}_x" = "${j}_x" ] && LOOP_DEV_EXIST="YES" && break
        done
        [ "$LOOP_DEV_EXIST" = "NO" ] && DEV="/dev/loop$i" && return 0
  
        i=$((i+1))
    done
 
    [ -z "$DEV" ] && die "ERR: no spare loop device under /dev/"
}

function find_unused_nbd_device_node ()
{
    is_cmd_installed "qemu-nbd"
    is_cmd_installed "modprobe"
 
    modprobe nbd max_part=128
    NUMS=$(lsblk|grep nbd|grep disk|cut -d' ' -f1|sed 's/nbd//')
    DEV=""
    for i in {0..100}
    do
        NBD_DEV_EXIST="NO"
        for j in $NUMS; do
            [ "${i}_x" = "${j}_x" ] && NBD_DEV_EXIST="YES" && break
        done
        [ "$NBD_DEV_EXIST" = "NO" ] && DEV="/dev/nbd$i" && return 0
  
        i=$((i+1))
    done
 
    [ -z "$DEV" ] && die "ERR: no spare nbd device under /dev/"
}


# INPUT: $*	mount_point [ mount_point ... ] 
function try_umount ()
{
    local N=0
    local MP MPOINTS=$*
    local TIMEOUT=10

    [ -z "$MPOINTS" ] && return 1

    for MP in $MPOINTS; do
        while findmnt "$MP" > /dev/null 2>&1 && test $N -lt $TIMEOUT; do
            umount $MP
            findmnt "$MP" > /dev/null 2>&1 || continue
            N=$(( $N + 1 ))
            echo -n "."
            sleep 1
        done
    done
}


# INPUT:    $1            mount_point  eg. /tmp/mnt.xxx
# OUTPUT:   STDOUT        eg. /tmp/mnt.xxx
#                         eg. /tmp/mnt.xxx/lib/overlay/3
function adjust_sysroot_for_hostname_even_for_microos()
{
    local d f id mp=$1

    [ -z "$mp" ] && return 1

    d=$mp/lib/overlay
    f=$d/transactional-update.newsnapshot

    if [ -d $d ]; then
        if [ -e $f ]; then
            id=$(sed -n 's/EXPECTED_SNAPSHOT_ID=\(\d*\)/\1/p' < $f)
        else
            id=$(ls $d|sort -n|grep "[0-9]\+"|tail -1)
        fi
    fi

    test -n "$id" && mp="$mp/lib/overlay/$id"
    echo $mp
}

# INPUT:    $1            mount_point  eg. /tmp/mnt.xxx
# OUTPUT:   STDOUT        eg. /tmp/mnt.xxx
#                         eg. /tmp/mnt.xxx/lib/overlay/3
function adjust_sysroot_for_sysconfig_network_even_for_microos()
{
    local d f id mp=$1

    [ -z "$mp" ] && return 1

    d=$mp/lib/overlay
    if test -d $d; then
      id=$(find $mp -path "$mp/lib/overlay/*/etc/sysconfig/network"|\
      sed -E "s%$mp\/lib\/overlay\/(.*)\/etc\/sysconfig\/network%\1%" | \
      sort -n|tail -1)
    fi

    test -n "$id" && mp=$mp/lib/overlay/$id
    echo $mp
}

# INPUT:    $1          mount_point  eg. /tmp/mnt.xxx
# OUTPUT:   STDOUT      eg. /tmp/mnt.xxx
#                       eg. /tmp/mnt.xxx/lib/overlay/3
function adjust_sysroot_for_hosts_even_for_microos()
{
    local d f id mp=$1

    [ -z "$mp" ] && return 1

    mp=$(adjust_sysroot_for_hostname_even_for_microos $mp)

    d=$mp/lib/overlay
    if test -d $d; then
        id=$(find $mp -path "$mp/lib/overlay/*/etc/hosts"|\
            sed -E "s%$mp\/lib\/overlay\/(.*)\/etc\/hosts%\1%" | \
            sort -n|tail -1)
    fi
    test -n "$id" && mp=$mp/lib/overlay/$id

    echo $mp
}

# INPUT:    $1          SYSROOT
#           $2          NEW_HOSTNAME
function reset_hostname()
{
    local d f id 
    local SYSROOT=$1
    local NEW_NAME=$2

    [ "$#" -lt 2 ] && return 1

    if [ -e $SYSROOT/etc/hostname ]; then
        run_cmd "cat $SYSROOT/etc/hostname"
    fi

    [ -d $SYSROOT/etc ] || mkdir $SYSROOT/etc

    echo $NEW_VM > $SYSROOT/etc/hostname 
    run_cmd "fsync $SYSROOT/etc/hostname"
    run_cmd "cat $SYSROOT/etc/hostname"
    echo -e "\rINFO: reset ${NEW_VM}:$SYSROOT/etc/hostname "
}


# INPUT:    $1          SYSROOT
#                       $SYSROOT/etc/sysconfig/network*
#                       eg. SYSROOT=$M_POINT
#                       eg. SYSROOT=$M_POINT/lib/overlay/?
function reset_static_ip_back_to_dhcp_if_any () 
{
    local RES NUN FNAME STR
    local SYSROOT=$1

    if ! [ -d $SYSROOT/etc/sysconfig ]; then
        echo "WARN: ip address check is ignored since no dir '$SYSROOT/etc/sysconfig'"
        return 1
    fi

    # 
    RES=$(find $SYSROOT/etc/sysconfig/network* -type f ! -name *lo ! -name *template -exec grep BOOTPROTO=.*static.* {} + )
    if [ -n "$RES" ] && ! [ "$NOT_RESET_DHCP" = "YES" ]; then 
        echo "INFO: reset ${NEW_VM}:static IP addresses to dhcp "
        run_cmd "find $SYSROOT/etc/sysconfig/network* \
            -type f ! -name *lo ! -name *template \
            -exec sed -i s/BOOTPROTO=.*static.*/BOOTPROTO=dhcp/ {} +"
        echo "INFO: reset $NEW_VM:$RES"
    fi
        
    RES=$(find $SYSROOT/etc/sysconfig/network* -type f ! -name *lo !  -name *template -exec grep -H ^IPADDR.*=.......* {} +)

    # reset all existent static ip in ORG_VM
    # replace the first one per request
    if [ -n "$RES" ]; then 

        # clean up all static cidr
        NUM=$(echo $RES|wc -l)
        if [ "$NUM" -gt 1 ]; then 
            run_cmd "find $SYSROOT/etc/sysconfig/network* \
                -type f ! -name *lo ! -name *template \
                -exec sed -i s/^\(IPADDR.*=\).......*/\1''/ {} +"
            echo "INFO: reset $NEW_VM:$RES to '' "
    
        fi

        if [ -n "$NEW_IP_CIDR" ]; then 
            # assign IP CIDR to the the first match in ifcfg-.*
            FNAME=$(echo $RES|head -1|sed 's/:.*$//')
            STR=$(echo ${NEW_IP_CIDR}|sed 's/\//\\\//g')
            run_cmd sed -i "0,/^\(IPADDR.*=\).......*/s/^\(IPADDR.*=\).......*/\1'$STR'/" $FNAME
            echo "INFO: reset $NEW_VM:$RES to '$NEW_IP_CIDR'"
        fi

    # no static ip in ORG_VM
    else 
        # add the static ip per request
        if [ -n "$NEW_IP_CIDR" ]; then 
            FNAME=$(find $SYSROOT/etc/sysconfig/network* -type f ! -name *lo !  -name *template -name ifcfg-* | head -1)
            if [ -n "$FNAME" ]; then
                echo "IPADDR=$NEW_IP_CIDR" >> $FNAME
                echo "INFO: add   $NEW_VM:$FNAME:IPADDR='$NEW_IP_CIDR'"
            fi
        fi
    fi

}


# INPUT:    $1          SYSROOT
#           $2          OLD_HOSTNAME
#           $3          NEW_HOSTNAME
#           NEW_IP_CIDR global variable
function reset_hosts ()
{
    local SYSROOT=$1
    local OLD_NAME=$2
    local NEW_NAME=$3
    local NEW_IP
    local RES

    [ "$#" -lt 3 ] && return 1
    if ! [ -e $SYSROOT/etc/hosts ]; then
        if [ -s "$TMP_HOSTS" ]; then
            cp $TMP_HOSTS $SYSROOT/etc/hosts
        else
            return 0
        fi
    fi

    #### reset /etc/hosts leftover from the old vm, if any 
    RES=$(grep -H "\<$OLD_NAME\>" $SYSROOT/etc/hosts)
    [ -n "$RES" ] && echo "INFO: reset $NEW_NAME:$RES"

    run_cmd "sed -i /$OLD_NAME/d $SYSROOT/etc/hosts"

    RES=$(grep -H "\<$NEW_NAME\>" $SYSROOT/etc/hosts)

    if [ -n "$NEW_IP_CIDR" ]; then
        NEW_IP=$(echo $NEW_IP_CIDR|cut -d'/' -f1)
        if [ -n "$RES" ]; then
            run_cmd sed "s/.*\(\<$NEW_NAME\>\).*/$NEW_IP	\1/"
            echo "INFO: reset $NEW_NAME:$SYSROOT/etc/hosts:$NEW_IP	$NEW_NAME"
        else
            echo "$NEW_IP	$NEW_NAME" >> $SYSROOT/etc/hosts
            echo "INFO: set   $NEW_NAME:$SYSROOT/etc/hosts:$NEW_IP	$NEW_NAME"
        fi
    else
        [ -n "$RES" ] && echo "INFO: $RES"
    fi
}

# INPUT: ${DEV}
function reset_hostname_in_block_device ()
{
    # Also deal with the filesystem image without partitions
    #try_cmd "partx --show --output NR - $DEV" ;# to fresh kernel data
    run_cmd "partprobe ${DEV}"     	  ;#fresh the kernel data
    run_cmd "lsblk -o NAME,FSTYPE -P $DEV" ;#both holder dev & its slaves
 
    #TEXT=$(echo "$CMD_STDOUT"|grep -e 'TYPE="xfs"' -e 'TYPE="btrfs"' \
    #-e 'TYPE="ext'|cut -d'"' -f2)
    TEXT=$(echo "$CMD_STDOUT"|grep -e 'TYPE="xfs"' -e 'TYPE="btrfs"' -e 'TYPE="ext')
 
    while IFS= read -r line; do
        log "... $line ..."
        NAME=$(echo $line|cut -d'"' -f2)
        FSTYPE=$(echo $line|cut -d'"' -f4)
  
        echo "INFO: processing /dev/$NAME $M_POINT $FSTYPE"
        run_cmd "mount /dev/$NAME $M_POINT"
  
        SYSROOT_ETC_HOSTNAME=$M_POINT
        SYSROOT_SYSCONFIG_NETWORK=$M_POINT
        SYSROOT_HOSTS=$M_POINT
        if [ $FSTYPE = "btrfs" ]; then 
            if [ $(btrfs property get -ts $M_POINT) = "ro=true" ]; then

                # /etc/hosts keeps in the root/readonly base image usually
                # copy it to a temporary place for further processing
                TMP_HOSTS=$(mktemp -p /run virt-dup.tmp.XXXXXXXX)
                [ "$SYSROOT_HOSTS" = "$M_POINT" ] && SYSROOT_HOSTS=$(adjust_sysroot_for_hosts_even_for_microos $M_POINT)
                NAME="$SYSROOT_HOSTS/etc/hosts"
                [ -e "$NAME" ] && cp $NAME $TMP_HOSTS

                # skip readonly btrfs in general
                try_umount $M_POINT
                continue
            else
                SYSROOT_ETC_HOSTNAME=$(adjust_sysroot_for_hostname_even_for_microos $M_POINT)
                SYSROOT_SYSCONFIG_NETWORK=$(adjust_sysroot_for_sysconfig_network_even_for_microos $M_POINT)
                SYSROOT_HOSTS=$(adjust_sysroot_for_hosts_even_for_microos $M_POINT)
            fi
        fi
  
        reset_hostname $SYSROOT_ETC_HOSTNAME $NEW_VM
        reset_static_ip_back_to_dhcp_if_any $SYSROOT_SYSCONFIG_NETWORK
        [ "$RESET_ETC_HOSTS" = "YES" ] && reset_hosts $SYSROOT_HOSTS $ORG_VM $NEW_VM
  
        try_umount $M_POINT
  
    done <<< "$TEXT"
}


# INPUT: ${IMG_FILE}
function reset_hostname_of_raw_image ()
{
    IMG_FILE="$1"
 
    find_unused_lo_device_node
    log "$DEV"
 
    run_cmd "losetup $DEV $IMG_FILE"
    reset_hostname_in_block_device $DEV
    run_cmd "losetup -d $DEV"
}


# INPUT: ${IMG_FILE}
function reset_hostname_via_qemu_nbd ()
{
    local tmp
 
    IMG_FILE="$1"
 
    find_unused_nbd_device_node
    log "$DEV"
 
    [ "$IS_DEBUG_VV" = "YES" ] && tmp="-v"
    #run_cmd "qemu-nbd $tmp --aio=native --nocache --connect=$DEV ${IMG_FILE}"
    run_cmd "qemu-nbd $tmp --connect=$DEV ${IMG_FILE}"
    reset_hostname_in_block_device $DEV
    run_cmd "qemu-nbd $tmp --disconnect $DEV"
}


# handle rootfs either in QCOW or RAW image
#
M_POINT="/tmp/mnt.$DOMAIN_DUP_RANDOM"
run_cmd "mkdir $M_POINT"
for i in $NEW_VM_IMG_FILES;
do
    run_cmd "file -b ${i}"
    if `echo $CMD_STDOUT|grep QCOW > /dev/null 2>&1`; then
       reset_hostname_via_qemu_nbd "$i"
    else
       reset_hostname_of_raw_image "$i"
    fi
done
run_cmd "rm -df $M_POINT"


# notify what image files won't change
for i in $IMG_FILES_WONT_CHANGE;
do
    echo "INFO: $i is shared among VMs"
done

####################################################################
echo -e "INFO: now have fun \n      virsh start $NEW_VM"
[ -z "$IS_DEBUG" ] || [ -e ${DUP_XML} ] && rm ${DUP_XML} 


# final cleanup
[ -s "$TMP_HOSTS" ] && rm "$TMP_HOSTS"


